<!-- /index.html -->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0" />
<title>Dungeon — Sprites + Gender + Shop/Stairs (Single-file)</title>
<style>
  html,body{margin:0;background:#0b0b0e;color:#ddd;font-family:system-ui,Segoe UI,Roboto,Ubuntu,Arial,sans-serif;overflow:hidden}
  #ui{position:fixed;inset:0;display:grid;grid-template-rows:auto 1fr auto;pointer-events:none}
  .topbar{display:flex;gap:16px;align-items:center;padding:8px 14px;background:linear-gradient(#191a1f,#111219);border-bottom:1px solid #2a2d39}
  .panel{background:rgba(15,16,22,0.9);border:1px solid #2a2d39;border-radius:10px;box-shadow:0 0 0 1px rgba(255,255,255,0.03) inset}
  .stat{height:14px;width:220px; background:#222;border:1px solid #333;border-radius:6px;position:relative}
  .fill{position:absolute;left:0;top:0;height:100%;background:#3c7}
  .fill.hp{background:#d44}
  .fill.mp{background:#47c}
  .fill.xp{background:#7a4bd9}
  .label{position:absolute;left:0;right:0;top:-18px;font-size:12px;opacity:.85;text-align:center}
  .hud-kv{font-size:13px;opacity:.9}
  #gameCanvas{position:fixed;left:0;top:0}
  .btn{display:inline-block;padding:8px 14px;border:1px solid #3a3e4d;border-radius:8px;background:#141622;color:#e6e6f0;cursor:pointer}
  .btn:hover{background:#1a1d2a}
  .stone{background-image:linear-gradient(180deg,rgba(255,255,255,.03),rgba(0,0,0,.08));}
  .footer{padding:6px 12px;border-top:1px solid #2a2d39;background:linear-gradient(#0f1016,#0b0c11);opacity:.85}
  #inventory{display:none;position:fixed;right:8px;top:64px;padding:8px 12px;pointer-events:auto;font-size:13px;max-width:340px}
  #shop{display:none;position:fixed;left:8px;top:64px;min-width:320px;padding:10px 12px;pointer-events:auto;font-size:13px}
  .list-row{display:flex;justify-content:space-between;gap:8px;padding:6px 6px;border-radius:6px}
  .list-row:hover{background:#1a1d28}
  .muted{opacity:.75}
  .kv{display:flex;gap:6px;align-items:center}
  .mono{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace}
  .pill{display:inline-block;padding:1px 6px;border:1px solid #2d3140;border-radius:999px;background:#10131c}
  .hr{height:1px;background:#2a2d39;margin:8px -8px}
  .hint{opacity:.8}
  .actions{display:flex;gap:8px;flex-wrap:wrap}
  .sml{padding:6px 8px;font-size:12px;border-radius:6px}
  .section-title{font-weight:bold;margin:6px 0 4px}
  .item-title{font-weight:600}
  .green{color:#76d38b}
  .red{color:#ff6b6b}
  .gender-card{display:flex;align-items:center;gap:10px;padding:8px;border:1px solid #2a2d39;border-radius:10px;cursor:pointer}
  .gender-card:hover{background:#12141f}
  .gender-card input{accent-color:#7a4bd9}
  .gender-preview{width:32px;height:32px;border-radius:6px;background:#0f1119;display:grid;place-items:center}
</style>
</head>
<body>
<canvas id="gameCanvas"></canvas>

<div id="ui">
  <div class="topbar">
    <div class="hud-kv"><b>Floor:</b> <span id="hudFloor">1</span> <span style="opacity:.5">|</span> <b>Seed:</b> <span id="hudSeed">-</span></div>
    <div class="stat panel" style="width:260px">
      <div id="hpFill" class="fill hp" style="width:70%"></div>
      <div class="label" id="hpLbl">HP 70/100</div>
    </div>
    <div class="stat panel" style="width:220px">
      <div id="mpFill" class="fill mp" style="width:40%"></div>
      <div class="label" id="mpLbl">Mana 40/100</div>
    </div>
    <div class="stat panel" style="width:220px">
      <div id="xpFill" class="fill xp" style="width:0%"></div>
      <div class="label" id="xpLbl">XP 0/50</div>
    </div>
    <div class="hud-kv"><b>Gold:</b> <span id="hudGold">0</span></div>
    <div class="hud-kv"><b>Lvl:</b> <span id="hudLvl">1</span></div>
    <div class="hud-kv" id="hudDmg" style="opacity:.85;margin-left:auto">ATK 2-4 | CRIT 5% | ARM 0</div>
    <div class="hud-kv" style="margin-left:8px; pointer-events:auto">
      <label style="display:flex;align-items:center;gap:6px;cursor:pointer">
        <input type="checkbox" id="smoothToggle" checked> Smooth
      </label>
    </div>
    <div class="hud-kv" style="display:flex;align-items:center;gap:6px; pointer-events:auto">
      <label for="speedRange">Speed</label>
      <input type="range" id="speedRange" min="60" max="220" value="140" step="5" style="width:140px">
    </div>
  </div>
  <div></div>
  <div class="footer">Sprites inline (base64) — offline single file</div>
</div>

<!-- Inventory -->
<div id="inventory" class="panel"></div>

<!-- Shop -->
<div id="shop" class="panel"></div>

<div id="start" class="stone" style="position:fixed;inset:0;display:grid;place-items:center">
  <div class="panel" style="padding:18px 22px;max-width:780px">
    <h2 style="margin:6px 0 12px 0">Dungeon</h2>
    <div style="display:flex;gap:16px;align-items:flex-start">
      <p style="flex:1;opacity:.9">Procedurally generated dungeon with fog‑of‑war. Pick a character, find loot, trade at the merchant, and descend the stairs.</p>
      <ul>
        <li>WASD / Arrow Keys — Move (8‑directional)</li>
        <li>I — Toggle Inventory</li>
        <li>E — Use Stairs / Merchant</li>
        <li>Click monster — Attack</li>
      </ul>
    </div>

    <div class="section-title" style="margin-top:10px">Choose your character</div>
    <div style="display:grid;grid-template-columns:1fr 1fr;gap:10px;pointer-events:auto">
      <label class="gender-card">
        <input type="radio" name="gender" value="m" checked>
        <div class="gender-preview"><img id="prevMale" alt="male" /></div>
        <div>
          <div><b>Male</b></div>
          <div class="muted" style="font-size:12px">Balanced adventurer</div>
        </div>
      </label>
      <label class="gender-card">
        <input type="radio" name="gender" value="f">
        <div class="gender-preview"><img id="prevFemale" alt="female" /></div>
        <div>
          <div><b>Female</b></div>
          <div class="muted" style="font-size:12px">Swift adventurer</div>
        </div>
      </label>
    </div>

    <p class="hint" style="margin-top:10px">All sprites (player, monsters, stairs, shop) are generated and embedded as base64 data URLs.</p>
    <div style="display:flex;gap:8px;margin-top:8px">
      <button id="playBtn" class="btn">Play</button>
      <button class="btn" onclick="alert('Thanks for playing!')">Quit</button>
    </div>
  </div>
</div>

<script>
// ===== Config / Globals =====
let VIEW_W=window.innerWidth, VIEW_H=window.innerHeight;
const TILE=32, MAP_W=48, MAP_H=48; const MONSTER_COUNT=24; const FOV_RADIUS=8; const LOOT_CHANCE=0.18;
const MONSTER_LOOT_CHANCE=0.3;
let canvas=document.getElementById('gameCanvas'); let ctx=canvas.getContext('2d');
function resizeCanvas(){ canvas.width = VIEW_W = window.innerWidth; canvas.height = VIEW_H = window.innerHeight; }
window.addEventListener('resize', resizeCanvas); resizeCanvas();
let camX=0, camY=0; let floorLayer=null, wallLayer=null;
// floor tile from provided image (scaled to 64×64 PNG for smaller payload)
const FLOOR_DATA =
  "data:image/png;base64," +
  "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";
const WALL_DATA="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAASUlEQVR4nGPMMjb+z4AHHH38mEGFnx+nPBM+zcSAUQMGgwGM+mJieNMBIcCiLSKCInD1zRsGa1lZnBqOPn7MgKxn4MNg1AAGBgDIxAxqYqux4wAAAABJRU5ErkJggg==";
const floorTex = (()=>{ const img=new Image(); img.src=FLOOR_DATA; return img; })();
const wallTex = (()=>{ const img=new Image(); img.src=WALL_DATA; return img; })();

// ====== Sprites (inline base64) ======
// why: generate pixel art once, store data URLs so everything stays single-file & offline
const SPRITES = {}; // key -> { url, cv }
function makeSprite(size, draw){ const c=document.createElement('canvas'); c.width=c.height=size; const g=c.getContext('2d'); g.imageSmoothingEnabled=false; draw(g, size); return { url: c.toDataURL('image/png'), cv: c }; }
function px(g,x,y,w,h,col){ g.fillStyle=col; g.fillRect(x,y,w,h); }
function outline(g,size){ g.globalCompositeOperation='destination-over'; g.strokeStyle='rgba(0,0,0,0.6)'; g.lineWidth=1; g.strokeRect(0.5,0.5,size-1,size-1); g.globalCompositeOperation='source-over'; }
function genSprites(){
  // Player male 24x24
  SPRITES.player_m = makeSprite(24,(g,S)=>{
    // boots & pants
    px(g,5,18,14,3,'#2b2f3a'); px(g,6,16,12,3,'#3a4060');
    // tunic
    px(g,6,10,12,6,'#7a9cff'); px(g,8,8,8,2,'#7a9cff');
    // arms
    px(g,5,12,2,4,'#d8bb9a'); px(g,17,12,2,4,'#d8bb9a');
    // head
    px(g,8,2,8,6,'#e3c6a6'); px(g,9,4,2,2,'#000'); px(g,13,4,2,2,'#000');
    // hair
    px(g,7,1,10,2,'#3c2c1a'); px(g,7,2,2,3,'#3c2c1a'); px(g,15,2,2,3,'#3c2c1a');
    outline(g,S);
  });

  // Player female 24x24
  SPRITES.player_f = makeSprite(24,(g,S)=>{
    // boots & leggings
    px(g,5,18,14,3,'#303446'); px(g,6,16,12,3,'#c65f92');
    // dress/armor
    px(g,6,10,12,6,'#ff7ab3'); px(g,8,8,8,2,'#ff7ab3');
    // arms
    px(g,5,12,2,4,'#f1d3b1'); px(g,17,12,2,4,'#f1d3b1');
    // head
    px(g,8,2,8,6,'#f1d3b1'); px(g,9,4,2,2,'#000'); px(g,13,4,2,2,'#000');
    // hair (long)
    px(g,7,1,10,2,'#6b3a2d'); px(g,6,3,2,6,'#6b3a2d'); px(g,16,3,2,6,'#6b3a2d');
    outline(g,S);
  });

  // Slime 24x24
  SPRITES.slime = makeSprite(24,(g,S)=>{
    px(g,4,10,16,10,'#6fd16f'); px(g,6,8,12,10,'#7ee27e'); px(g,8,6,8,8,'#9bf09b');
    px(g,9,11,2,2,'#134013'); px(g,13,11,2,2,'#134013');
    outline(g,S);
  });
  // Bat 24x24
  SPRITES.bat = makeSprite(24,(g,S)=>{
    // wings
    px(g,2,12,8,6,'#20222b'); px(g,14,12,8,6,'#20222b');
    // body
    px(g,9,10,6,8,'#2e3240'); px(g,10,8,4,3,'#2e3240');
    px(g,10,12,1,2,'#9b0000'); px(g,13,12,1,2,'#9b0000');
    outline(g,S);
  });
  // Skeleton 24x24
  SPRITES.skeleton = makeSprite(24,(g,S)=>{
    px(g,7,2,10,6,'#e9edf1'); px(g,9,4,2,2,'#000'); px(g,13,4,2,2,'#000');
    px(g,8,10,8,6,'#dde3ea'); px(g,6,10,2,4,'#dde3ea'); px(g,16,10,2,4,'#dde3ea');
    px(g,8,18,3,3,'#dde3ea'); px(g,13,18,3,3,'#dde3ea');
    outline(g,S);
  });

  // Mage/Cultist 24x24 (caster enemy)
  SPRITES.mage = makeSprite(24,(g,S)=>{
    // robe
    px(g,6,8,12,10,'#4a3a7e'); px(g,8,6,8,3,'#4a3a7e');
    // trim
    px(g,6,16,12,2,'#b84aff');
    // head
    px(g,8,2,8,4,'#e6c9a6'); px(g,9,3,2,2,'#000'); px(g,13,3,2,2,'#000');
    // staff/glow
    px(g,3,6,2,14,'#7a5cff'); px(g,2,6,4,2,'#b84aff');
    outline(g,S);
  });

  // Stairs (down) 24x24
  SPRITES.stairs = makeSprite(24,(g,S)=>{
    // tile base
    px(g,2,2,20,20,'#2a2e3a');
    // steps
    px(g,4,5,16,3,'#c7a34a'); px(g,4,9,16,3,'#b69241'); px(g,4,13,16,3,'#a6833a'); px(g,4,17,16,3,'#977634');
    // shadow
    g.globalAlpha=0.25; px(g,14,4,2,16,'#000'); g.globalAlpha=1;
    outline(g,S);
  });

  // Merchant goblin 24x24 (with lootbag)
  SPRITES.shop_goblin = makeSprite(24,(g,S)=>{
    // bag
    px(g,3,14,8,6,'#6b4b2a'); px(g,4,13,6,2,'#7a5a37');
    // goblin body
    px(g,12,6,8,8,'#6fcf5a'); px(g,10,10,12,8,'#6fcf5a');
    // eyes
    px(g,14,9,2,2,'#000'); px(g,18,9,2,2,'#000');
    // ear
    px(g,10,7,2,2,'#6fcf5a'); px(g,20,7,2,2,'#6fcf5a');
    // belt
    px(g,10,15,12,2,'#3a2a1a');
    outline(g,S);
  });

  // Merchant stall 24x24 (alternative)
  SPRITES.shop_stall = makeSprite(24,(g,S)=>{
    // counter
    px(g,2,12,20,8,'#6b3f2b'); px(g,3,11,18,2,'#7e4a33');
    // legs
    px(g,3,20,3,2,'#3a2318'); px(g,18,20,3,2,'#3a2318');
    // canopy
    px(g,2,3,20,6,'#b84aff'); px(g,2,3,4,6,'#ffd24a'); px(g,10,3,4,6,'#ffd24a'); px(g,18,3,4,6,'#ffd24a');
    outline(g,S);
  });

  // Merchant tile (purple marker) for visibility hint
  SPRITES.merchant_tile = makeSprite(24,(g,S)=>{ px(g,4,4,16,16,'#8a5cff'); outline(g,S); });

  // previews on start screen
  const prevMale=document.getElementById('prevMale'); const prevFemale=document.getElementById('prevFemale');
  if(prevMale) prevMale.src = SPRITES.player_m.url; if(prevFemale) prevFemale.src = SPRITES.player_f.url;
}

// generate immediately so previews show on start
genSprites();

let seed=(Math.random()*1e9)|0, floorNum=1, rng=new RNG(seed);
let map=[], fog=[], vis=[]; let rooms=[]; let stairs={x:0,y:0};
let merchant={x:0,y:0}; let merchantStyle = Math.random()<0.5 ? 'goblin' : 'stall';
let player={x:0,y:0,hp:100,hpMax:100,mp:60,mpMax:60,gold:0,stepCD:0,stepDelay:140,speedPct:0,lvl:1,xp:0,xpToNext:50,baseAtkBonus:0, gender:'m'};
let playerSpriteKey = 'player_m';
// Monsters now have richer AI with per-type patterns and scaling
// {x,y,rx,ry,type,hp,hpMax,dmgMin,dmgMax,atkCD,moveCD,state:{...},hitFlash}
let monsters=[];
// Simple projectile pool for ranged/magic attacks
// {x,y,dx,dy,speed,damage,type,alive}
let projectiles=[];
// floating combat text
let damageTexts=[];
const SLOTS=["helmet","chest","legs","hands","feet","weapon"];
let equip={helmet:null,chest:null,legs:null,hands:null,feet:null,weapon:null};
const BAG_SIZE=12; let bag=new Array(BAG_SIZE).fill(null);
let shopStock=[];

// HUD refs
const hpFill=document.getElementById('hpFill'); const mpFill=document.getElementById('mpFill');
const hpLbl=document.getElementById('hpLbl'); const mpLbl=document.getElementById('mpLbl');
const hudFloor=document.getElementById('hudFloor'); const hudSeed=document.getElementById('hudSeed'); const hudGold=document.getElementById('hudGold'); const hudDmg=document.getElementById('hudDmg');
const xpFill=document.getElementById('xpFill'); const xpLbl=document.getElementById('xpLbl'); const hudLvl=document.getElementById('hudLvl');

// --- Smooth helpers & settings ---
function smoothstep01(t){ return t*t*(3-2*t); }
function lerp(a,b,t){ return a + (b-a)*t; }
function walkable(x,y){ if(x<0||y<0||x>=MAP_W||y>=MAP_H) return false; const t=map[y*MAP_W+x]; return t!==T_WALL && t!==T_EMPTY; }
function canMoveFrom(x,y,dx,dy){
  const nx=x+dx, ny=y+dy;
  if(!walkable(nx,ny)) return false;
  if(dx!==0 && dy!==0){ if(!walkable(x+dx,y) && !walkable(x,y+dy)) return false; }
  return true;
}
let smoothEnabled = true; let baseStepDelay = 140; // sync to player.stepDelay on start

// ===== RNG =====
function RNG(seed){ this.s=seed|0; }
RNG.prototype.next=function(){ this.s=(this.s*1664525+1013904223)|0; return ((this.s>>>0)/4294967296); }
RNG.prototype.int=function(a,b){ return Math.floor(a + (b-a+1)*this.next()); }

// ===== Map / Gen =====
const T_EMPTY=0, T_FLOOR=1, T_WALL=2;
function generate(){
  map=new Array(MAP_W*MAP_H).fill(T_EMPTY);
  fog=new Array(MAP_W*MAP_H).fill(0);
  vis=new Array(MAP_W*MAP_H).fill(0);
  rooms=[]; monsters=[]; projectiles=[]; lootMap.clear();
  // rooms
  for(let i=0;i<28;i++){
    const w=rng.int(6,11), h=rng.int(6,11);
    const x=rng.int(1,MAP_W-w-1), y=rng.int(1,MAP_H-h-1);
    rooms.push({x,y,w,h});
    for(let yy=y; yy<y+h; yy++) for(let xx=x; xx<x+w; xx++) map[yy*MAP_W+xx]=T_FLOOR;
  }
  // corridors
  for(let i=1;i<rooms.length;i++){
    const a=rooms[i-1], b=rooms[i];
    for(let x=Math.min(a.x,b.x); x<=Math.max(a.x,b.x); x++) map[(a.y+((a.h/2)|0))*MAP_W+x]=T_FLOOR;
    for(let y=Math.min(a.y,b.y); y<=Math.max(a.y,b.y); y++) map[y*MAP_W+(b.x+((b.w/2)|0))]=T_FLOOR;
  }
  // walls
  for(let y=0;y<MAP_H;y++) for(let x=0;x<MAP_W;x++) if(map[y*MAP_W+x]===T_FLOOR){ for(const d of [[1,0],[-1,0],[0,1],[0,-1]]){ const nx=x+d[0], ny=y+d[1]; if(nx>=0&&ny>=0&&nx<MAP_W&&ny<MAP_H && map[ny*MAP_W+nx]===T_EMPTY) map[ny*MAP_W+nx]=T_WALL; } }
  // place player + stairs + merchant
  const r=rooms[rng.int(0,rooms.length-1)]; player.x=r.x+((r.w/2)|0); player.y=r.y+((r.h/2)|0);
  let rr=rooms[rng.int(0,rooms.length-1)]; stairs.x=rr.x+((rr.w/2)|0); stairs.y=rr.y+((rr.h/2)|0);
  let rm=rooms[rng.int(0,rooms.length-1)];
  merchant.x=rm.x+((rm.w/2)|0); merchant.y=rm.y+((rm.h/2)|0);
  if(merchant.x===player.x && merchant.y===player.y){ merchant.x=rng.int(rm.x+1,rm.x+rm.w-2); merchant.y=rng.int(rm.y+1,rm.y+rm.h-2); }
  if(merchant.x===stairs.x && merchant.y===stairs.y){ merchant.x=rng.int(rm.x+1,rm.x+rm.w-2); merchant.y=rng.int(rm.y+1,rm.y+rm.h-2); }

  // monsters
  for(let i=0;i<MONSTER_COUNT;i++){
    const r=rooms[rng.int(0,rooms.length-1)];
    const x=rng.int(r.x+1,r.x+r.w-2), y=rng.int(r.y+1,r.y+r.h-2);
    if((x===player.x && y===player.y) || (x===merchant.x && y===merchant.y)) continue;
    const t=rng.int(0,3); // 0=slime, 1=bat, 2=skeleton, 3=mage
    monsters.push(spawnMonster(t,x,y));
  }

  buildLayers();
  recomputeFOV();
  seedRoomLoot();
  genShopStock();
  redrawInventory();
  renderShop();
}

// ===== Difficulty scaling & Monster factory =====
const SCALE = { HP_PER_FLOOR: 6, DMG_PER_FLOOR: 1 };
function scaleStat(base, perFloor){ return Math.max(1, Math.floor(base + perFloor * Math.max(0, floorNum-1))); }
function spawnMonster(type,x,y){
  // Base stats per archetype
  const archetypes = [
    { hp:16, dmg:[2,4], atkCD:28, moveCD:[6,10] },    // slime: sturdy melee
    { hp:12, dmg:[1,3], atkCD:22, moveCD:[4,8] },     // bat: fast swoop
    { hp:14, dmg:[2,5], atkCD:38, moveCD:[6,10] },    // skeleton: ranged
    { hp:12, dmg:[3,6], atkCD:30, moveCD:[6,10] },    // mage: caster (magic)
  ];
  const a = archetypes[type] || archetypes[0];
  const m = {
    x, y, rx:x, ry:y, type,
    hpMax: scaleStat(a.hp, SCALE.HP_PER_FLOOR),
    hp: 0,
    dmgMin: scaleStat(a.dmg[0], SCALE.DMG_PER_FLOOR),
    dmgMax: scaleStat(a.dmg[1], SCALE.DMG_PER_FLOOR),
    atkCD: rng.int(10, a.atkCD), // frames
    moveCD: rng.int(a.moveCD[0], a.moveCD[1]),
    state: {}, hitFlash:0, moving:false, moveT:1, moveDur:140, fromX:x, fromY:y, toX:x, toY:y
  };
  m.hp = m.hpMax;
  return m;
}

// Helpers
function sign(n){ return n===0?0:(n>0?1:-1); }
function clearPathCardinal(x1,y1,x2,y2){
  if(x1!==x2 && y1!==y2) return false;
  const dx=sign(x2-x1), dy=sign(y2-y1);
  let x=x1+dx, y=y1+dy;
  while(!(x===x2 && y===y2)){
    if(isBlock(x,y)) return false;
    x+=dx; y+=dy;
  }
  return true;
}
// 8-directional LoS (grid step); simple check for caster
function clearPath8(x1,y1,x2,y2){
  let dx = sign(x2-x1), dy = sign(y2-y1);
  if(dx===0 && dy===0) return true;
  let x=x1+dx, y=y1+dy;
  while(!(x===x2 && y===y2)){
    if(isBlock(x,y)) return false;
    if(x!==x2) x+=dx;
    if(y!==y2) y+=dy;
  }
  return true;
}

function buildLayers(){
  floorLayer=document.createElement('canvas'); floorLayer.width=MAP_W*TILE; floorLayer.height=MAP_H*TILE;
  wallLayer=document.createElement('canvas'); wallLayer.width=MAP_W*TILE; wallLayer.height=MAP_H*TILE;
  const f=floorLayer.getContext('2d'), w=wallLayer.getContext('2d');
  f.fillStyle=f.createPattern(floorTex,'repeat'); f.fillRect(0,0,floorLayer.width,floorLayer.height);
  // mask non-floor
  const mask=document.createElement('canvas'); mask.width=floorLayer.width; mask.height=floorLayer.height;
  const mg=mask.getContext('2d'); mg.fillStyle='#000'; mg.fillRect(0,0,mask.width,mask.height);
  mg.globalCompositeOperation='destination-out';
  mg.fillStyle='#fff';
  for(let y=0;y<MAP_H;y++) for(let x=0;x<MAP_W;x++) if(map[y*MAP_W+x]===T_FLOOR){ mg.fillRect(x*TILE,y*TILE,TILE,TILE); }
  f.drawImage(mask,0,0);
  // walls
  w.fillStyle=w.createPattern(wallTex,'repeat');
  for(let y=0;y<MAP_H;y++) for(let x=0;x<MAP_W;x++) if(map[y*MAP_W+x]===T_WALL) w.fillRect(x*TILE,y*TILE,TILE,TILE);
}

// ===== FOV =====
function isBlock(x,y){ if(x<0||y<0||x>=MAP_W||y>=MAP_H) return true; return map[y*MAP_W+x]===T_WALL || map[y*MAP_W+x]===T_EMPTY; }
function recomputeFOV(){
  vis.fill(0);
  const rays=360;
  for(let a=0;a<rays;a++){
    const ang=a*Math.PI*2/rays; let x=player.x+0.5, y=player.y+0.5;
    for(let r=0;r<FOV_RADIUS*2;r++){
      const ix=x|0, iy=y|0; if(ix<0||iy<0||ix>=MAP_W||iy>=MAP_H) break;
      const idx=iy*MAP_W+ix; vis[idx]=1; fog[idx]=Math.max(fog[idx],1);
      if(isBlock(ix,iy) && !(ix===player.x && iy===player.y)) break;
      x+=Math.cos(ang)*0.5; y+=Math.sin(ang)*0.5;
    }
  }
}

// ===== Loot / Inventory =====
const TYPES=['helmet','chest','legs','hands','feet','weapon'];
const WEAPONS=['Sword','Axe','Mace','Dagger','Bow','Wand','Staff'];
const RARITY=[{n:'Common',c:'#c0c8d0'},{n:'Magic',c:'#4aa3ff'},{n:'Rare',c:'#ffd24a'},{n:'Epic',c:'#b84aff'}];
let lootMap=new Map();

function affixMods(slot){
  const R={};
  if(slot==='weapon'){ R.dmgMin=(rng.int(0,2)); R.dmgMax=(rng.int(1,4)); if(rng.next()<0.25) R.crit=rng.int(2,6); }
  if(slot!=='weapon'){ if(rng.next()<0.5) R.armor=rng.int(1,4); }
  // elemental/magic resists are more common on armor
  if(slot!=='weapon'){ if(rng.next()<0.30) R.resFire=rng.int(2,10); }
  if(slot!=='weapon'){ if(rng.next()<0.30) R.resIce=rng.int(2,10); }
  if(slot!=='weapon'){ if(rng.next()<0.30) R.resShock=rng.int(2,10); }
  if(rng.next()<0.18) R.resMagic=rng.int(2,12);
  if(rng.next()<0.3) R.hpMax=rng.int(5,20);
  if(rng.next()<0.2) R.mpMax=rng.int(5,15);
  if(rng.next()<0.2) R.speedPct=rng.int(2,8);
  if(rng.next()<0.15) R.ls=rng.int(1,4);
  if(rng.next()<0.15) R.mp=rng.int(1,6);
  return R;
}

function seedRoomLoot(){
  for(const r of rooms){ if(rng.next()<LOOT_CHANCE){ const x=rng.int(r.x+1,r.x+r.w-2), y=rng.int(r.y+1,r.y+r.h-2); lootMap.set(`${x},${y}`,{color:'#ffd24a',type:'gold',amt:rng.int(5,20)}); } }
}

function pickupHere(){
  const key = `${player.x},${player.y}`;
  const it = lootMap.get(key);
  if(!it) return;
  if(it.type === 'gold'){
    player.gold += it.amt; hudGold.textContent = player.gold; showToast(`+${it.amt} gold`); lootMap.delete(key); return;
  }
  const idx = bag.findIndex(b=>!b);
  if(idx === -1){ showToast('Bag full'); return; }
  bag[idx] = it; lootMap.delete(key); showToast(`Picked up ${it.name}`);
  redrawInventory();
}

function equipFromBag(idx){
  const it = bag[idx]; if(!it) return;
  const slot = it.slot; const prev = equip[slot];
  equip[slot] = it; bag[idx] = prev || null; showToast(`Equipped ${it.name}`);
  redrawInventory(); recalcStats();
}

function unequip(slot){
  const it = equip[slot]; if(!it) return;
  const idx = bag.findIndex(b=>!b); if(idx === -1){ showToast('Bag full'); return; }
  bag[idx] = it; equip[slot] = null; showToast(`Unequipped ${it.name}`);
  redrawInventory(); recalcStats();
}

function dropFromBag(idx){ const it=bag[idx]; if(!it) return; lootMap.set(`${player.x},${player.y}`,it); bag[idx]=null; showToast(`Dropped ${it.name}`); redrawInventory(); }

function sellFromBag(idx){ const it=bag[idx]; if(!it) return; const price=getSellPrice(it); player.gold+=price; hudGold.textContent=player.gold; showToast(`Sold ${it.name} for ${price}`); bag[idx]=null; redrawInventory(); }

function unequipAndSell(slot){ const it=equip[slot]; if(!it) return; const price=getSellPrice(it); equip[slot]=null; player.gold+=price; hudGold.textContent=player.gold; showToast(`Sold ${it.name} for ${price}`); redrawInventory(); recalcStats(); }

function redrawInventory(){
  let panel = document.getElementById('inventory'); if(!panel){ panel=document.createElement('div'); panel.id='inventory'; panel.className='panel'; document.body.appendChild(panel); }
  let html = '';
  html += '<div class="section-title">Equipped</div>';
  html += '<div>';
  for(const slot of SLOTS){
    const it = equip[slot];
    const name = it?`<span style="color:${it.color}">${escapeHtml(it.name)}</span>`:'-';
    html += `<div class="list-row" data-type="eq" data-slot="${slot}"><div>${slot}: ${name}</div><div class="muted">${it?shortMods(it):''}</div></div>`;
  }
  html += '</div><div class="hr"></div>';
  html += '<div class="section-title">Bag</div>';
  for(let i=0;i<BAG_SIZE;i++){
    const it = bag[i];
    html += `<div class="list-row" data-type="bag" data-idx="${i}"><div>${i+1}. ${it?`<span style="color:${it.color}">${escapeHtml(it.name)}</span>`:'(empty)'}</div><div class="muted">${it?shortMods(it):''}</div></div>`;
  }
  html += '<div class="hr"></div>';
  html += '<div id="invDetails" class="muted">Hover an item to see details. Click bag item to Equip. Click equipped item to Unequip. Use buttons below for Sell/Drop.</div>';
  html += '<div class="actions" style="margin-top:8px"><button id="btnSell" class="btn sml" disabled>Sell</button><button id="btnDrop" class="btn sml" disabled>Drop</button></div>';
  panel.innerHTML = html;

  // events (why: keep DOM light using delegation instead of many listeners)
  panel.onmouseover = (e)=>{
    const row = e.target.closest('.list-row'); if(!row) return; showItemDetailsFromRow(row);
  };
  panel.onclick = (e)=>{
    const row = e.target.closest('.list-row'); if(row){
      const t=row.dataset.type; if(t==='bag'){ equipFromBag(parseInt(row.dataset.idx,10)); } else if(t==='eq'){ unequip(row.dataset.slot); }
    }
  };
  document.getElementById('btnSell').onclick = ()=>{
    const sel = document.getElementById('invDetails').dataset.sel;
    const kind = document.getElementById('invDetails').dataset.kind;
    if(kind==='bag'){ sellFromBag(parseInt(sel,10)); }
    if(kind==='eq'){ unequipAndSell(sel); }
  };
  document.getElementById('btnDrop').onclick = ()=>{
    const sel = document.getElementById('invDetails').dataset.sel;
    const kind = document.getElementById('invDetails').dataset.kind;
    if(kind==='bag'){ dropFromBag(parseInt(sel,10)); }
  };
}

function showItemDetailsFromRow(row){
  const det = document.getElementById('invDetails');
  det.dataset.sel=''; det.dataset.kind='';
  const t=row.dataset.type;
  if(t==='bag'){
    const i=parseInt(row.dataset.idx,10); const it=bag[i]; if(!it){ setDetailsText('(empty slot)'); disableInvActions(); return; }
    det.dataset.sel=String(i); det.dataset.kind='bag';
    setDetailsText(renderDetails(it, 'bag'));
    document.getElementById('btnSell').disabled=false; document.getElementById('btnDrop').disabled=false;
  }else if(t==='eq'){
    const slot=row.dataset.slot; const it=equip[slot]; if(!it){ setDetailsText(`No ${slot} equipped.`); disableInvActions(); return; }
    det.dataset.sel=slot; det.dataset.kind='eq';
    setDetailsText(renderDetails(it, 'eq'));
    document.getElementById('btnSell').disabled=false; document.getElementById('btnDrop').disabled=true; // avoid dropping equipped directly
  }
}

function disableInvActions(){ document.getElementById('btnSell').disabled=true; document.getElementById('btnDrop').disabled=true; }
function setDetailsText(html){ const det=document.getElementById('invDetails'); det.innerHTML=html; }

function shortMods(it){ const m=it.mods||{}; const bits=[];
  if(m.dmgMin||m.dmgMax) bits.push(`ATK ${m.dmgMin||0}-${m.dmgMax||0}`);
  if(m.crit) bits.push(`CR ${m.crit}%`);
  if(m.armor) bits.push(`ARM ${m.armor}`);
  if(m.hpMax) bits.push(`HP+${m.hpMax}`);
  if(m.mpMax) bits.push(`MP+${m.mpMax}`);
  if(m.speedPct) bits.push(`SPD+${m.speedPct}%`);
  if(m.ls) bits.push(`LS ${m.ls}%`);
  if(m.mp) bits.push(`MPo+${m.mp}`);
  const rf=m.resFire||0, ri=m.resIce||0, rs=m.resShock||0, rm=m.resMagic||0;
  if(rf||ri||rs||rm) bits.push(`RES F/I/S/M ${rf}/${ri}/${rs}/${rm}`);
  return bits.join(' · ');
}

function renderDetails(it, origin){
  const val = getItemValue(it); const sell = getSellPrice(it);
  const lines = [];
  lines.push(`<div class="item-title" style="color:${it.color}">${escapeHtml(it.name)}</div>`);
  lines.push(`<div class="muted">${it.slot} · ${RARITY[it.rarity]?.n||'?'}</div>`);
  const m = it.mods||{}; const rows = [];
  if(m.dmgMin||m.dmgMax) rows.push(`<div>Attack: <span class="mono">${m.dmgMin||0}-${m.dmgMax||0}</span></div>`);
  if(m.crit) rows.push(`<div>Crit: <span class="mono">+${m.crit}%</span></div>`);
  if(m.armor) rows.push(`<div>Armor: <span class="mono">+${m.armor}</span></div>`);
  if(m.hpMax) rows.push(`<div>HP Max: <span class="mono">+${m.hpMax}</span></div>`);
  if(m.mpMax) rows.push(`<div>MP Max: <span class="mono">+${m.mpMax}</span></div>`);
  if(m.speedPct) rows.push(`<div>Speed: <span class="mono">+${m.speedPct}%</span></div>`);
  if(m.ls) rows.push(`<div>Lifesteal: <span class="mono">${m.ls}%</span></div>`);
  if(m.mp) rows.push(`<div>Mana on hit: <span class="mono">+${m.mp}</span></div>`);
  if(m.resFire||m.resIce||m.resShock||m.resMagic){
    rows.push(`<div>Resists (F/I/S/M): <span class="mono">${m.resFire||0}/${m.resIce||0}/${m.resShock||0}/${m.resMagic||0}%</span></div>`);
  }
  if(rows.length===0) rows.push('<div class="muted">No magical properties.</div>');
  lines.push(`<div style="margin:6px 0">${rows.join('')}</div>`);
  lines.push(`<div class="kv"><span class="pill">Value ${val}</span><span class="pill">Sell ${sell}</span>${origin==='shop'?'<span class="pill">Buy</span>':''}</div>`);
  return lines.join('');
}

// ===== Values / Shop =====
function getItemValue(it){
  const rBase=[10,25,60,120][it.rarity||0];
  const slotFactor = it.slot==='weapon'?1.25:1.0;
  const m=it.mods||{}; let score=0;
  score+= (m.dmgMin||0)*4 + (m.dmgMax||0)*6;
  score+= (m.crit||0)*3 + (m.armor||0)*3;
  score+= (m.hpMax||0)*0.8 + (m.mpMax||0)*0.6 + (m.speedPct||0)*4;
  score+= (m.ls||0)*6 + (m.mp||0)*2;
  score+= ((m.resFire||0)+(m.resIce||0)+(m.resShock||0))*1.2 + (m.resMagic||0)*1.8;
  const floorBonus = Math.max(0,floorNum-1)*4;
  return Math.max(5, Math.floor((rBase + score)*slotFactor + floorBonus));
}
function getSellPrice(it){ return Math.floor(getItemValue(it)*0.5); }

function genShopStock(){
  shopStock.length=0;
  const count=5; for(let i=0;i<count;i++) shopStock.push(makeRandomItem());
}

function makeRandomItem(){
  const slot = SLOTS[rng.int(0, SLOTS.length-1)];
  const rarityIdx = rng.int(0, RARITY.length-1);
  const base = slot === 'weapon' ? WEAPONS[rng.int(0, WEAPONS.length-1)] : slot.charAt(0).toUpperCase()+slot.slice(1);
  const name = `${RARITY[rarityIdx].n} ${base}`;
  const item = { color: RARITY[rarityIdx].c, type:'gear', slot, name, rarity: rarityIdx, mods: affixMods(slot) };
  item.price = clamp(8, 9999, Math.floor(getItemValue(item) * (1.0 + (floorNum-1)*0.05)));
  return item;
}

function renderShop(){
  const panel=document.getElementById('shop');
  let h='';
  h += '<div style="display:flex;align-items:center;justify-content:space-between;gap:8px;margin-bottom:6px">';
  h += '<div class="section-title">Merchant</div>';
  h += '<div class="kv">Gold: <b id="shopGold" class="mono">'+player.gold+'</b></div>';
  h += '</div>';
  h += '<div class="muted" style="margin-bottom:6px">Stand on the merchant and press <b>E</b> to open/close. Click an item to buy.</div>';
  for(let i=0;i<shopStock.length;i++){
    const it=shopStock[i];
    h += `<div class="list-row" data-idx="${i}">`+
         `<div><div class="item-title" style="color:${it.color}">${escapeHtml(it.name)}</div>`+
         `<div class="muted">${it.slot} · ${shortMods(it)}</div></div>`+
         `<div class="kv"><div class="pill mono">${it.price}g</div><button class="btn sml" data-buy="${i}">Buy</button></div>`+
         `</div>`+
         `<div class="muted" style="margin:-6px 6px 6px 6px">${renderDetails(it,'shop')}</div>`;
  }
  h += '<div class="hr"></div><div class="actions"><button id="shopRefresh" class="btn sml">Refresh (15g)</button><button id="shopClose" class="btn sml">Close</button></div>';
  panel.innerHTML=h;
  panel.onclick=(e)=>{
    const b=e.target.closest('button'); if(!b) return;
    if(b.id==='shopClose'){ toggleShop(false); return; }
    if(b.id==='shopRefresh'){ if(player.gold>=15){ player.gold-=15; hudGold.textContent=player.gold; genShopStock(); renderShop(); } else showToast('Need 15 gold'); return; }
    if(b.dataset.buy){ const idx=parseInt(b.dataset.buy,10); buyItem(idx); }
  };
}

function buyItem(idx){
  const it=shopStock[idx]; if(!it) return;
  if(player.gold<it.price){ showToast('Not enough gold'); return; }
  const slot=bag.findIndex(b=>!b); if(slot===-1){ showToast('Bag full'); return; }
  player.gold-=it.price; hudGold.textContent=player.gold; bag[slot]=stripShopFields(it); showToast(`Bought ${it.name}`); shopStock.splice(idx,1); renderShop(); redrawInventory();
}
function stripShopFields(it){ const {price,...rest}=it; return rest; }

function toggleShop(show){ const el=document.getElementById('shop'); el.style.display=show?'block':'none'; if(show){ renderShop(); document.getElementById('shopGold').textContent=player.gold; } }

// ===== Combat / Click =====
canvas.addEventListener('mousedown', (e)=>{
  const rect=canvas.getBoundingClientRect(); const mx=(e.clientX-rect.left); const my=(e.clientY-rect.top);
  const tx = Math.floor((mx+camX)/TILE), ty=Math.floor((my+camY)/TILE);
  const m = monsters.find(mm=>mm.x===tx && mm.y===ty);
  if(!m) return;
  const {min,max,crit,ls} = currentAtk();
  let dmg=rng.int(min, max);
  if(Math.random()*100 < crit) dmg = Math.floor(dmg*1.5);
  dmg=Math.max(1,dmg);
  m.hp-=dmg; m.hitFlash=4;
  if(ls>0){ const heal=Math.max(1,Math.floor(dmg*ls/100)); player.hp=Math.min(player.hpMax, player.hp+heal); }
});

function currentAtk(){
  // why: single source-of-truth for attack numbers (incl. level & gear)
  let min=2,max=4,crit=5,ls=0;
  const lvlBonus = Math.floor((player.lvl-1)*0.6); min+=lvlBonus; max+=lvlBonus;
  const w=equip.weapon?.mods||{}; min+=w.dmgMin||0; max+=w.dmgMax||0; crit += w.crit||0; ls=w.ls||0; return {min,max,crit,ls};
}

function applyDamageToPlayer(dmg, type='physical'){
  // Armor DR (applies to physical/ranged only)
  const armor = player.armor||0;
  const K = 50 + 10 * Math.max(0, floorNum-1);
  const armorDR = Math.max(0, Math.min(0.8, armor / (armor + K)));
  let afterArmor = dmg;
  if(type==='physical' || type==='ranged'){ afterArmor = Math.max(1, Math.floor(dmg * (1 - armorDR))); }

  // Elemental/magic resist (percentage, capped)
  const cap = 75;
  const rF = clamp(0, cap, player.resFire||0);
  const rI = clamp(0, cap, player.resIce||0);
  const rS = clamp(0, cap, player.resShock||0);
  const rM = clamp(0, cap, player.resMagic||0);
  const resPct = (type==='fire')?rF : (type==='ice')?rI : (type==='shock')?rS : (type==='magic')?rM : 0;
  const eff = Math.max(1, Math.floor(afterArmor * (1 - resPct/100)));

  player.hp = Math.max(0, player.hp - eff);
  damageTexts.push({ tx:player.x, ty:player.y, text:`-${eff}`, color:(type==='magic'?'#b84aff':'#ff6b6b'), age:0, ttl:900 });
  if(player.hp===0){ showToast('You died… Press E on stairs next time 😅'); }
}

// ===== Monster AI & Movement =====
function tryMoveMonster(m, dx, dy, dur=140){
  const nx=m.x+dx, ny=m.y+dy;
  if(!walkable(nx,ny)) return false;
  m.x=nx; m.y=ny;
  if(smoothEnabled){ m.fromX=m.rx; m.fromY=m.ry; m.toX=nx; m.toY=ny; m.moveT=0; m.moving=true; m.moveDur=dur; }
  else{ m.rx=m.x; m.ry=m.y; m.moving=false; m.moveT=1; }
  return true;
}

function meleeIfAdjacent(m){
  if(Math.abs(m.x-player.x)+Math.abs(m.y-player.y)!==1) return false;
  if(m.atkCD>0) return false;
  const dmg = rng.int(m.dmgMin, m.dmgMax);
  applyDamageToPlayer(dmg);
  m.atkCD = rng.int(20, 35);
  return true;
}

function monsterAI(m, dt){
  // Cooldowns tick in frames scaled by dt
  m.atkCD = Math.max(0, m.atkCD - 1);
  m.moveCD = Math.max(0, m.moveCD - 1);

  // Shared: if adjacent, attempt melee
  if(meleeIfAdjacent(m)) return;

  const dx = sign(player.x - m.x), dy = sign(player.y - m.y);
  const manhattan = Math.abs(player.x-m.x)+Math.abs(player.y-m.y);

  if(m.type===0){ // Slime — slow chase, occasional 2-tile charge
    if(m.state.chargeSteps>0){
      if(tryMoveMonster(m, m.state.cdx, m.state.cdy, 110)) m.state.chargeSteps--;
      else m.state.chargeSteps=0;
      return;
    }
    if(m.moveCD===0){
      // 30% chance to start a short charge when near
      if(manhattan<=3 && m.atkCD===0 && rng.next()<0.3){
        m.state.cdx = dx; m.state.cdy = dy; m.state.chargeSteps = 2;
        m.atkCD = 12; // short windup
      }else{
        // Greedy step toward player, prefer axis with larger distance
        const stepX = tryMoveMonster(m, dx, 0, 150);
        if(!stepX) tryMoveMonster(m, 0, dy, 150);
      }
      m.moveCD = rng.int(6, 10);
    }
  } else if(m.type===1){ // Bat — fast diagonal swoop
    if(m.state.swoop>0){
      // continue swoop; if hits wall, cancel
      const ok = tryMoveMonster(m, m.state.sdx, m.state.sdy, 90);
      m.state.swoop = ok ? m.state.swoop-1 : 0;
      return;
    }
    if(manhattan<=6 && m.atkCD===0 && m.moveCD===0){
      // start a 2-step swoop (diagonal favored)
      m.state.sdx = dx!==0?dx:0; m.state.sdy = dy!==0?dy:0;
      if(m.state.sdx===0 && m.state.sdy===0){ m.state.sdx = (rng.next()<0.5?1:-1); }
      m.state.swoop = 2;
      m.atkCD = 18;
      m.moveCD = 2;
      return;
    }
    if(m.moveCD===0){
      // wander toward player quickly
      if(!tryMoveMonster(m, dx, dy, 110)){
        if(!tryMoveMonster(m, dx, 0, 110)) tryMoveMonster(m, 0, dy, 110);
      }
      m.moveCD = rng.int(4, 8);
    }
  } else if(m.type===2) { // Skeleton — ranged: shoot if LoS, otherwise shuffle toward
    if(manhattan<=7 && clearPathCardinal(m.x,m.y,player.x,player.y) && m.atkCD===0){
      // fire arrow
      const adx = sign(player.x - m.x), ady = sign(player.y - m.y);
      projectiles.push({ x:m.x+0.5, y:m.y+0.5, dx:adx, dy:ady, speed:10/1000, damage:rng.int(m.dmgMin,m.dmgMax), type:'ranged', alive:true });
      m.atkCD = rng.int(26, 40);
      return;
    }
    if(m.moveCD===0){
      // slow shuffle
      if(!tryMoveMonster(m, dx, 0, 160)) tryMoveMonster(m, 0, dy, 160);
      m.moveCD = rng.int(6, 10);
    }
  } else { // Mage — caster: maintain distance, shoot magic bolts with 8-dir LoS
    const preferRange = 5; // keep around 4-6 tiles away
    if(manhattan<=8 && clearPath8(m.x,m.y,player.x,player.y) && m.atkCD===0){
      const adx = sign(player.x - m.x), ady = sign(player.y - m.y);
      projectiles.push({ x:m.x+0.5, y:m.y+0.5, dx:adx, dy:ady, speed:8/1000, damage:rng.int(m.dmgMin,m.dmgMax+2), type:'magic', alive:true });
      m.atkCD = rng.int(24, 34);
      return;
    }
    if(m.moveCD===0){
      // too close -> step away; too far/blocked -> step toward
      if(manhattan<=preferRange-1){
        if(!tryMoveMonster(m, -dx, 0, 150)) tryMoveMonster(m, 0, -dy, 150);
      }else{
        if(!tryMoveMonster(m, dx, 0, 150)) tryMoveMonster(m, 0, dy, 150);
      }
      m.moveCD = rng.int(6, 10);
    }
  }
}

// ===== Drawing =====
function draw(dt){
  const maxX=MAP_W*TILE - VIEW_W, maxY=MAP_H*TILE - VIEW_H;
  const camTileX = (smoothEnabled && player.rx!==undefined ? player.rx : player.x);
  const camTileY = (smoothEnabled && player.ry!==undefined ? player.ry : player.y);
  camX = Math.max(0, Math.min(camTileX*TILE - VIEW_W/2, maxX));
  camY = Math.max(0, Math.min(camTileY*TILE - VIEW_H/2, maxY));

  ctx.clearRect(0,0,VIEW_W,VIEW_H);
  ctx.drawImage(floorLayer, -camX, -camY);
  ctx.drawImage(wallLayer, -camX, -camY);

  // stairs (sprite)
  const stairsX = stairs.x*TILE - camX + (TILE-24)/2; const stairsY = stairs.y*TILE - camY + (TILE-24)/2;
  ctx.drawImage(SPRITES.stairs.cv, stairsX, stairsY);

  // merchant (sprite)
  if(vis[merchant.y*MAP_W+merchant.x]){
    const mx = merchant.x*TILE - camX + (TILE-24)/2; const my = merchant.y*TILE - camY + (TILE-24)/2;
    const sprite = merchantStyle==='goblin'? SPRITES.shop_goblin.cv : SPRITES.shop_stall.cv;
    ctx.drawImage(sprite, mx, my);
  }

  // loot
  for(const [k,it] of lootMap.entries()){
    const [lx,ly]=k.split(',').map(Number);
    if(vis[ly*MAP_W+lx]){
      const lxpx = lx*TILE - camX + (TILE-14)/2;
      const lypy = ly*TILE - camY + (TILE-14)/2;
      ctx.fillStyle=it.color; ctx.fillRect(lxpx, lypy, 14, 14);
    }
  }

  // monsters (sprites by type)
  for(const m of monsters){
    if(!vis[m.y*MAP_W+m.x]) continue;
    const mtx = (m.rx!==undefined ? m.rx : m.x);
    const mty = (m.ry!==undefined ? m.ry : m.y);
    const mx = mtx*TILE - camX + (TILE-24)/2; const my = mty*TILE - camY + (TILE-24)/2;
    const key = m.type===0?'slime' : m.type===1?'bat' : m.type===2?'skeleton' : 'mage';
    ctx.drawImage(SPRITES[key].cv, mx, my);
    if(m.hitFlash>0){ ctx.globalAlpha=0.5; ctx.fillStyle='#ff6666'; ctx.fillRect(mx,my,24,24); ctx.globalAlpha=1; }
    // hp bar
    ctx.fillStyle='#111'; ctx.fillRect(mx, my-6, 24, 3);
    ctx.fillStyle='#e33'; const hw=24*(Math.max(0,m.hp)/m.hpMax); ctx.fillRect(mx, my-6, hw, 3);
    if(m.hitFlash>0) m.hitFlash--;
    if(m.hp<=0){
      if(Math.random()<MONSTER_LOOT_CHANCE) dropLoot(m.x,m.y);
      if(Math.random()<0.55){ lootMap.set(`${m.x},${m.y}`,{color:'#ffd24a',type:'gold',amt:rng.int(3,12)}); }
      grantXP(10 + rng.int(0,6));
      const idx=monsters.indexOf(m); if(idx>=0) monsters.splice(idx,1);
    }
  }

  // projectiles
  for(const p of projectiles){
    if(!p.alive) continue;
    const px = p.x*TILE - camX - 3, py = p.y*TILE - camY - 3;
    ctx.fillStyle = (p.type==='magic') ? '#b84aff' : '#ffd24a';
    ctx.fillRect(px, py, 6, 6);
  }

  // player (sprite)
  const ptx = (smoothEnabled && player.rx!==undefined ? player.rx : player.x);
  const pty = (smoothEnabled && player.ry!==undefined ? player.ry : player.y);
  const px = ptx*TILE - camX + (TILE-24)/2; const py = pty*TILE - camY + (TILE-24)/2;
  ctx.drawImage(SPRITES[playerSpriteKey].cv, px, py);

  // floating damage texts
  for(const t of damageTexts){
    const tx = t.tx*TILE - camX;
    const ty = t.ty*TILE - camY - (t.age/100)*20;
    ctx.fillStyle = t.color || '#ff6b6b';
    ctx.font = 'bold 14px sans-serif';
    ctx.fillText(t.text, tx+8, ty);
    t.age += dt;
  }
  damageTexts = damageTexts.filter(t=>t.age < t.ttl);

  // fog
  ctx.fillStyle='#000';
  for(let y=0;y<MAP_H;y++)for(let x=0;x<MAP_W;x++){ if(fog[y*MAP_W+x]===0) ctx.fillRect(x*TILE - camX, y*TILE - camY, TILE, TILE); }
  ctx.fillStyle='rgba(0,0,0,0.6)';
  for(let y=0;y<MAP_H;y++)for(let x=0;x<MAP_W;x++){ const idx=y*MAP_W+x; const v=fog[idx]; const vv=vis[idx]; if(v && !vv) ctx.fillRect(x*TILE - camX, y*TILE - camY, TILE, TILE); }

  // HUD
  hpFill.style.width=(100*player.hp/player.hpMax).toFixed(0)+'%';
  mpFill.style.width=(100*player.mp/player.mpMax).toFixed(0)+'%';
  const xpPct = Math.min(100, Math.floor(100*player.xp/Math.max(1,player.xpToNext)));
  xpFill.style.width = xpPct+'%'; xpLbl.textContent=`XP ${player.xp}/${player.xpToNext}`; hudLvl.textContent=player.lvl;
  hpLbl.textContent=`HP ${player.hp}/${player.hpMax}`; mpLbl.textContent=`Mana ${player.mp}/${player.mpMax}`;
}

// ===== Update (smooth tween + 8-dir) =====
function update(dt){
  // init render state
  if(player.rx===undefined){
    player.rx=player.x; player.ry=player.y; player.fromX=player.x; player.fromY=player.y; player.toX=player.x; player.toY=player.y; player.moving=false; player.moveT=1; player.moveDur=player.stepDelay; baseStepDelay = player.stepDelay || baseStepDelay;
  }
  for(const m of monsters){ if(m.rx===undefined){ m.rx=m.x; m.ry=m.y; m.moving=false; m.moveT=1; m.moveDur=140; } }

  // inputs
  player.stepCD = Math.max(0, player.stepCD - dt);
  if(player.stepCD<=0 && !player.moving){
    const up=!!(keys['ArrowUp']||keys['w']||keys['W']);
    const down=!!(keys['ArrowDown']||keys['s']||keys['S']);
    const left=!!(keys['ArrowLeft']||keys['a']||keys['A']);
    const right=!!(keys['ArrowRight']||keys['d']||keys['D']);
    const dx = (right && !left) ? 1 : (left && !right) ? -1 : 0;
    const dy = (down && !up) ? 1 : (up && !down) ? -1 : 0;
    if(dx||dy){
      if(canMoveFrom(player.x, player.y, dx, dy)){
        const nx=player.x+dx, ny=player.y+dy;
        player.x=nx; player.y=ny; pickupHere(); recomputeFOV();
        const diag = (dx!==0 && dy!==0) ? Math.SQRT2 : 1;
        const gearFactor = (1 - Math.min(0.5, player.speedPct/100));
        const dur = Math.max(60, baseStepDelay * gearFactor * diag);
        player.moveDur = dur; player.stepCD = dur;
        if(smoothEnabled){ player.fromX=player.rx; player.fromY=player.ry; player.toX=player.x; player.toY=player.y; player.moveT=0; player.moving=true; }
        else{ player.rx=player.x; player.ry=player.y; player.moving=false; player.moveT=1; }
      }
    }
  }

  // advance player tween
  if(smoothEnabled && player.moving){
    player.moveT = Math.min(1, player.moveT + dt / player.moveDur);
    const t=smoothstep01(player.moveT);
    player.rx=lerp(player.fromX,player.toX,t); player.ry=lerp(player.fromY,player.toY,t);
    if(player.moveT>=1){ player.moving=false; player.rx=player.toX; player.ry=player.toY; }
  }else{ player.rx=player.x; player.ry=player.y; }

  // monster AI ticks every frame
  for(const m of monsters){ monsterAI(m, dt); }
  // advance monster tweens
  for(const m of monsters){
    if(m.moving){ m.moveT=Math.min(1,m.moveT + dt / m.moveDur); const t=smoothstep01(m.moveT); m.rx=lerp(m.fromX,m.toX,t); m.ry=lerp(m.fromY,m.toY,t); if(m.moveT>=1){ m.moving=false; m.rx=m.toX; m.ry=m.toY; } }
    else{ m.rx=m.x; m.ry=m.y; }
  }

  // projectiles update
  for(const p of projectiles){
    if(!p.alive) continue;
    // move in tile units per ms
    p.x += p.dx * p.speed * dt * TILE;
    p.y += p.dy * p.speed * dt * TILE;
    const tx = Math.floor(p.x), ty = Math.floor(p.y);
    // stop on walls
    if(isBlock(tx,ty)){ p.alive=false; continue; }
    // hit player if sharing tile
    if(tx===player.x && ty===player.y){
      applyDamageToPlayer(p.damage, p.type||'ranged');
      p.alive=false;
    }
  }
  // cleanup dead projectiles
  if(projectiles.length>64){ projectiles = projectiles.filter(p=>p.alive); }
}

// ===== Input =====
const keys={};
window.addEventListener('keydown',e=>{ keys[e.key]=true; if(e.key==='i'||e.key==='I') toggleInv(); });
window.addEventListener('keyup',e=>{ keys[e.key]=false; });
window.addEventListener('keypress',e=>{
  if(e.key==='e'||e.key==='E'){
    if(player.x===stairs.x && player.y===stairs.y){
      floorNum++; seed=(seed*1664525+1013904223)|0; rng=new RNG(seed);
      generate(); hudFloor.textContent=floorNum; hudSeed.textContent=seed>>>0; showToast('Down we go'); toggleShop(false);
    } else if(player.x===merchant.x && player.y===merchant.y){ toggleShop(document.getElementById('shop').style.display!=='block'); renderShop(); }
  }
});

// ===== Inventory UI (toggle only) =====
function toggleInv(){ let panel=document.getElementById('inventory'); if(!panel){ redrawInventory(); panel=document.getElementById('inventory'); } if(!panel) return; const show=panel.style.display===''||panel.style.display==='none'; panel.style.display=show?'block':'none'; if(show) redrawInventory(); }

// ===== Loot helpers =====
function dropLoot(x,y){
  const slot = SLOTS[rng.int(0, SLOTS.length-1)];
  const rarityIdx = rng.int(0, RARITY.length-1);
  const base = slot === 'weapon' ? WEAPONS[rng.int(0, WEAPONS.length-1)] : slot.charAt(0).toUpperCase()+slot.slice(1);
  const name = `${RARITY[rarityIdx].n} ${base}`;
  const item = { color: RARITY[rarityIdx].c, type: 'gear', slot, name, rarity: rarityIdx, mods: affixMods(slot) };
  lootMap.set(`${x},${y}`, item);
}

// ===== XP / Leveling =====
function grantXP(x){ player.xp+=x; while(player.xp>=player.xpToNext){ player.xp-=player.xpToNext; levelUp(); } }
function levelUp(){ player.lvl++; const hpGain=12, mpGain=6; player.hpMax+=hpGain; player.mpMax+=mpGain; player.baseAtkBonus+=1; player.hp=player.hpMax; player.mp=player.mpMax; player.xpToNext = Math.floor(50*Math.pow(1.35, player.lvl-1)); recalcStats(); showToast(`Level up! Lv ${player.lvl}`); }

// ===== Toast =====
let toastTimer=0; function showToast(msg){ const bar=document.querySelector('.topbar'); const span=document.createElement('span'); span.style.marginLeft='8px'; span.style.opacity=.85; span.textContent='• '+msg; bar.appendChild(span); clearTimeout(toastTimer); toastTimer=setTimeout(()=>{ if(span.parentNode) span.remove(); }, 1600); }

// ===== Stats =====
function recalcStats(){
  let dmgMin=2,dmgMax=4,crit=5,armor=0; let hpMax=100, mpMax=60, speedPct=0;
  let resF=0,resI=0,resS=0,resM=0;
  // level bonus
  const lvlBonus = Math.floor((player.lvl-1)*0.6) + (player.baseAtkBonus||0);
  dmgMin += lvlBonus; dmgMax += lvlBonus;
  for(const slot of SLOTS){
    const it=equip[slot]; if(!it) continue; const m=it.mods;
    if(m.dmgMin) dmgMin+=m.dmgMin; if(m.dmgMax) dmgMax+=m.dmgMax; if(m.crit) crit+=m.crit; if(m.armor) armor+=m.armor; if(m.hpMax) hpMax+=m.hpMax; if(m.mpMax) mpMax+=m.mpMax; if(m.speedPct) speedPct+=m.speedPct;
    resF += m.resFire||0; resI += m.resIce||0; resS += m.resShock||0; resM += m.resMagic||0;
  }
  player.hpMax=hpMax; player.mpMax=mpMax; player.speedPct=speedPct; if(player.hp>hpMax) player.hp=hpMax; if(player.mp>mpMax) player.mp=mpMax;
  player.armor = armor;
  player.resFire=resF; player.resIce=resI; player.resShock=resS; player.resMagic=resM;
  hudDmg.textContent = `ATK ${dmgMin}-${dmgMax} | CRIT ${crit}% | ARM ${armor} | RES F/I/S/M ${resF}/${resI}/${resS}/${resM}`;
  hpFill.style.width = `${(player.hp/player.hpMax)*100}%`; mpFill.style.width = `${(player.mp/player.mpMax)*100}%`;
  hpLbl.textContent = `HP ${player.hp}/${player.hpMax}`; mpLbl.textContent = `Mana ${player.mp}/${player.mpMax}`;
}

// ===== Main Loop =====
let __last = performance.now();
function loop(now){ const dt = Math.min(50, now - __last); __last = now; update(dt); draw(dt); requestAnimationFrame(loop); }

// ===== Start =====
function startGame(){
  // gender pick -> sprite
  const gSel = document.querySelector('input[name="gender"]:checked');
  player.gender = (gSel?.value==='f')?'f':'m';
  playerSpriteKey = player.gender==='f' ? 'player_f' : 'player_m';

  hudFloor.textContent=floorNum; hudSeed.textContent=seed>>>0; hudGold.textContent=player.gold; hudLvl.textContent=player.lvl;
  generate(); recalcStats(); recomputeFOV();
  const smoothToggle=document.getElementById('smoothToggle'); const speedRange=document.getElementById('speedRange');
  if(smoothToggle){ smoothToggle.checked = smoothEnabled; smoothToggle.addEventListener('change', e=>{ smoothEnabled = e.target.checked; if(!smoothEnabled){ player.rx=player.x; player.ry=player.y; } }); }
  if(speedRange){ baseStepDelay = player.stepDelay; speedRange.value = String(baseStepDelay); speedRange.addEventListener('input', e=>{ const v=parseInt(e.target.value,10); if(!isNaN(v)) baseStepDelay=v; }); }
  requestAnimationFrame(loop);
}

document.getElementById('playBtn').onclick=()=>{ document.getElementById('start').style.display='none'; startGame(); };

// ===== Utils =====
function clamp(a,b,x){ return Math.max(a, Math.min(b, x)); }
function escapeHtml(s){ return String(s).replace(/[&<>"']/g, c=>({"&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;"}[c])); }
</script>
</body>
</html>
